"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(require("os"));
const process_1 = __importDefault(require("process"));
const allure_js_commons_1 = require("allure-js-commons");
const jest_environment_node_1 = __importDefault(require("jest-environment-node"));
const AllureJestApi_1 = require("./AllureJestApi");
const utils_1 = require("./utils");
const { ALLURE_HOST_NAME, ALLURE_THREAD_NAME, JEST_WORKER_ID } = process_1.default.env;
const hostname = os_1.default.hostname();
class AllureJest extends jest_environment_node_1.default {
    constructor(config, context) {
        super(config, context);
        this.runningTests = new Map();
        this.runtime = new allure_js_commons_1.AllureRuntime({
            resultsDir: "allure-results",
        });
        this.global.allure = new AllureJestApi_1.AllureJestApi(this, this.global);
        this.testRootDirPath = config.projectConfig.rootDir;
        this.global.hello = "world";
    }
    setup() {
        return super.setup();
    }
    teardown() {
        return super.teardown();
    }
    handleAllureMetadata(payload) {
        const currentTest = this.runningTests.get(payload.currentTestName);
        currentTest.applyMetadata(payload.metadata);
    }
    handleTestEvent(event, state) {
        switch (event.name) {
            case "add_test":
                this.handleTestAdd({
                    testName: event.testName,
                    concurrent: event.concurrent,
                    state,
                });
                break;
            case "test_start":
                this.handleTestStart(event.test);
                break;
            case "test_todo":
                this.handleTestTodo(event.test);
                break;
            case "test_fn_success":
                this.handleTestPass(event.test);
                break;
            case "test_fn_failure":
                this.handleTestFail(event.test);
                break;
            case "test_skip":
                this.handleTestSkip(event.test);
                break;
            case "test_done":
                this.handleTestDone(event.test);
                break;
            default:
                break;
        }
    }
    handleTestAdd(payload) {
        const { testName, state } = payload;
        const { currentDescribeBlock } = state;
        const newTestSuitesPath = (0, utils_1.getTestPath)(currentDescribeBlock);
        const newTestPath = newTestSuitesPath.concat(testName);
        const newTestID = (0, utils_1.getTestId)(newTestPath);
        const newTest = new allure_js_commons_1.AllureTest(this.runtime);
        const thread = ALLURE_THREAD_NAME || JEST_WORKER_ID || process_1.default.pid.toString();
        const host = ALLURE_HOST_NAME || hostname;
        newTest.name = testName;
        newTest.fullName = newTestID;
        newTest.addLabel(allure_js_commons_1.LabelName.LANGUAGE, "javascript");
        newTest.addLabel(allure_js_commons_1.LabelName.FRAMEWORK, "jest");
        if (thread) {
            newTest.addLabel(allure_js_commons_1.LabelName.THREAD, thread);
        }
        if (host) {
            newTest.addLabel(allure_js_commons_1.LabelName.HOST, host);
        }
        (0, allure_js_commons_1.getSuitesLabels)(newTestSuitesPath).forEach((label) => {
            newTest.addLabel(label.name, label.value);
        });
        this.runningTests.set(newTestID, newTest);
    }
    handleTestStart(test) {
        const currentTestID = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
        const currentTest = this.runningTests.get(currentTestID);
        currentTest.stage = allure_js_commons_1.Stage.RUNNING;
    }
    handleTestPass(test) {
        const currentTestID = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
        const currentTest = this.runningTests.get(currentTestID);
        currentTest.stage = allure_js_commons_1.Stage.FINISHED;
        currentTest.status = allure_js_commons_1.Status.PASSED;
    }
    handleTestFail(test) {
        const currentTestID = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
        const currentTest = this.runningTests.get(currentTestID);
        const [error] = test.errors;
        const hasMultipleErrors = Array.isArray(error);
        currentTest.stage = allure_js_commons_1.Stage.FINISHED;
        currentTest.status = allure_js_commons_1.Status.FAILED;
        currentTest.statusDetails = {
            message: hasMultipleErrors ? error[0].message : error.message,
            trace: hasMultipleErrors ? error[0].stack : error.stack,
        };
    }
    handleTestSkip(test) {
        const currentTestID = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
        const currentTest = this.runningTests.get(currentTestID);
        currentTest.stage = allure_js_commons_1.Stage.PENDING;
        currentTest.status = allure_js_commons_1.Status.SKIPPED;
        currentTest.endTest();
        this.runningTests.delete(currentTestID);
    }
    handleTestDone(test) {
        const currentTestID = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
        const currentTest = this.runningTests.get(currentTestID);
        currentTest.endTest();
        this.runningTests.delete(currentTestID);
    }
    handleTestTodo(test) {
        const currentTestID = (0, utils_1.getTestId)((0, utils_1.getTestPath)(test));
        const currentTest = this.runningTests.get(currentTestID);
        currentTest.stage = allure_js_commons_1.Stage.PENDING;
        currentTest.status = allure_js_commons_1.Status.SKIPPED;
        currentTest.endTest();
        this.runningTests.delete(currentTestID);
    }
}
exports.default = AllureJest;
//# sourceMappingURL=AllureJest.js.map